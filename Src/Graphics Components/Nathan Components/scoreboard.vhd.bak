library IEEE;
use IEEE.NUMERIC_STD.ALL;
use IEEE.std_logic_1164.all;
use IEEE.Std_logic_Arith.all;


use work.graphicsPackage.all;

entity scoreboard is
port(
	score : in integer;
	clk : in std_logic;
	hcount : in integer;
	vcount : in integer;
	scoreboard_out : out scoreboard_data := init_scoreboard
);

end entity;

architecture myscoreboard of scoreboard is

	component fontROM is
		generic(
			addrWidth: integer := 11;
			dataWidth: integer := 8
		);
		port(
			clkA: in std_logic;
			writeEnableA: in std_logic;
			addrA: in std_logic_vector(addrWidth-1 downto 0);
			dataOutA: out std_logic_vector(dataWidth-1 downto 0);
			dataInA: in std_logic_vector(dataWidth-1 downto 0)
		);
	end component;
	
	component binary_to_bcd IS
	GENERIC(
		bits   : INTEGER := 10;  --size of the binary input numbers in bits
		digits : INTEGER := 3);  --number of BCD digits to convert to
	PORT(
		clk     : IN    STD_LOGIC;                             --system clock
		reset_n : IN    STD_LOGIC;                             --active low asynchronus reset
		ena     : IN    STD_LOGIC;                             --latches in new binary number and starts conversion
		binary  : IN    STD_LOGIC_VECTOR(bits-1 DOWNTO 0);     --binary number to convert
		busy    : OUT  STD_LOGIC;                              --indicates conversion in progress
		bcd     : OUT  STD_LOGIC_VECTOR(digits*4-1 DOWNTO 0)); --resulting BCD number
	END component;

	---- FONT INFORMATION ----
	signal fontAddrIn : STD_LOGIC_VECTOR(10 downto 0);
	signal fontDataOut : STD_LOGIC_VECTOR(0 to 7);
	signal fontBitEn : std_logic;
	
	signal pixelOn : boolean;
	signal inScoreboard : std_logic := '0';
	--------------------------
	
	signal testInt, testIntBuffer : integer := 1234;
	signal testSTDV : std_logic_vector(6 downto 0);
	
	signal zeroDigit, onesDigit, twosDigit, threesDigit : integer;
	
	
	---- Binary to BCD ----
	signal clkCount : integer:= 0;
	signal numBits : integer := 10;
	signal numDigits : integer := 3;
	signal bin_bcd_Ena : std_logic := '0'; 
	signal binaryIn : std_logic_vector(numBits-1 DOWNTO 0);
	signal busySig : std_logic;
	signal bcdOut : std_logic_vector(numDigits*4-1 DOWNTO 0);
	-----------------------
	
begin

	charSet: entity work.fontROM
		generic map(
			addrWidth => 11,
			dataWidth => 8
		)
		port map(
			clkA => clk,
			writeEnableA => '0', -- never write
			addrA => fontAddrIn,
			dataOutA => fontDataOut,
			dataInA => (others => '0')
		);
		
	bin_to_bcd : entity work.binary_to_bcd
		
  GENERIC MAP(
    bits => 10,  					--size of the binary input numbers in bits
    digits => 3)  				--number of BCD digits to convert to
  PORT MAP(
    clk => clk,               --system clock
    reset_n => '1',           --active low asynchronus reset
    ena => bin_bcd_Ena,       --latches in new binary number and starts conversion
    binary => binaryIn,     	--binary number to convert
    busy => busySig,          --indicates conversion in progress
    bcd => bcdOut);				--resulting BCD number

	scoreOutput: process(hcount, vcount)
	begin
	
	binaryIn <= "1000110101";
	
	--zeroDigit <= testInt mod 10;
	--testIntBuffer <= to_integer(shift_right(to_integer(testInt), 1));
	--onesDigit <= testIntBuffer mod 10;
	--testIntBuffer <= to_integer(shift_right(to_integer(testIntBuffer), 1));
	--twosDigit <= testIntBuffer mod 10;
	--testIntBuffer <= to_integer(shift_right(to_integer(testIntBuffer), 1));
	--threesDigit <= testIntBuffer mod 10;
	
	case(bcdOut(3 downto 0)) is
		when "0000" => testSTDV <= "0110000";
		when "0001" => testSTDV <= "0110001";
		when "0010" => testSTDV <= "0110010";
		when "0011" => testSTDV <= "0110011";
		when "0100" => testSTDV <= "0110100";
		when "0101" => testSTDV <= "0110101";
		when "0110" => testSTDV <= "0110110";
		when "0111" => testSTDV <= "0110111";
		when "1000" => testSTDV <= "0111000";
		when "1001" => testSTDV <= "0111001";
		when others => testSTDV <= "0000001";
	end case;

		--if(rising_edge(clk)) then
		--clkCount <= clkCount + 1;
			--if(clkCount >= clkPrescaler) then
				--clkCount <= 0;
				
				-----SCOREBOARD LOGIC-----------
				if (hcount >= 622 AND hcount < 630 AND vcount >= 4 AND vcount < 20) then
					inScoreboard <= '1';--scoreboard_out.pixelOn <= true;
					--pixelOn <= true;
				else
					inScoreboard <= '0';--scoreboard_out.pixelOn <= false;
					--pixelOn <= false;
				end if;
				
				fontAddrIn <= (testSTDV & conv_std_logic_vector(vcount - 4, 4));
				fontBitEn <= fontDataOut(hcount - 622);
				
				if((inScoreboard = '1') AND (fontBitEn = '1')) then
					scoreboard_out.pixelOn <= true;
				else
					scoreboard_out.pixelOn <= false;
				end if;				
				--------------------------------
				
			--end if;		
		--end if;

	end process;

	enablebcdtobin : process(clk)	
	begin
		clkCount <= clkCount + 1;
		if(clkCount > 500000) then
			clkCount <= 0;
			bin_bcd_Ena <= not bin_bcd_Ena;
		end if;
	end process;
	

end architecture;